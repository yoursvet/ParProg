// Механизмы синхронизации
/*
	Необходимо задать взаимное время (шкалу) каким-то образом,
	которая замеряет очередь - какой поток и что делает.
*/

//Синхронизация потоков
/*
	- "Метод задания соответствия потоков команд во времени"
	1. Взаимное исключение - mutual exclusion (mutex) - объект ядра ОС, который позволяет разным программам синхронизироваться
		У мьютекса 2 состояния:
		владеем/свободен,
		блокирован/сигнален

	(Сети Петри используются при моделировании системы)
	
	Критические секции / фьютекс / спин-счётчики (функции мьютекса)
	Критическая секция позволяет выполнять следующую процедуру:
		Пока ресурс занят:
			Вытесниться
	Например, из расписания поток убирается, пока ресурс занят (циклически)

	Спин счётчики:
		пока i < 6000 и (ресурс занят):
			Вытесниться и i++;
		если i == 6000 --> поток переходит в состояние владения мьютексом
	*/

/*

	Участок кода в OpenMP
	#pragma omp critical {
		..Здесь выполнение кода каждым потоком по-очереди
	}
	говорит о том, что участок кода должен защищаться от гонки потоков (т.е. один поток должен выполнять этот участок кода в одно время.

	omp_mutex_lock(h) - по состоянию мьютекса h можно осуществлять синхронизацию
	Покинутый mutex - тот, которому не сделали unlock(). 
	Mutex - это такая же память, которую необходимо освобождать.
	(Abandoned)

	2. Монитор
	Главная его задача в том, чтобы сигнализировать об определённом событии.
	
	События (в Win используются) - Events.
		SetEvent/ResetEvent
		WaitFor* - функция

	СемафОры
	Свободны несколько раз (это как мьютексы, только которыми можно завладеть только n-ое кол-во раз)
	Mutex - частный случай Семафоров, только который пропускает 1 поток. А Семафор может пропускать до n потоков
	Переменные условия - наиболее распространённый случай Семафоров - (condition_variable CV)
	Под условием подразумевается некоторый предикат. Если условие удовлетворено, то сигнал от монитора идёт...

	У переменных-условий есть следующий интерфейс (абстрактно):
	CV {
		wait(mtx)
		notify()
		notify_all()
	}

	Монитор работает следующим образом:
	Можно осуществить ожидание некоторого события или сигнала.
	Пусть есть потоки t = 0 и t = 1.
	Если один из потоков начинает осуществлять ожидание (cv.wait();), то поток начинает быть заблокирован, пока
	другой поток не вызовет метод cv.notify(), чтобы другой поток продолжил работу.






*/